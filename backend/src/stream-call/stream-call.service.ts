import { HttpException, HttpStatus, Injectable, Inject, forwardRef } from '@nestjs/common';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { Session, SessionDocument } from './session.schema';
import { User } from '../users/users.schema';
import {PatientService} from '../profiles/services/patient.service'
import {AppointmentsService} from '../appointments/appointments.service'
import { parse } from 'path';
import { min } from 'class-validator';


const OpenTok = require("opentok");
const opentok = new OpenTok(process.env.VONAGE_VIDEO_API_KEY, process.env.VONAGE_VIDEO_SECRET, { timeout: 60000});



@Injectable()
export class StreamCallService {
    constructor(
        @InjectModel(Session.name) private sessionModel: Model<SessionDocument>,
        @Inject( forwardRef( () => AppointmentsService ) ) private appointmentsService: AppointmentsService
    ) {}


    /**
     * This function creates a new session for a patient and a doctor using OpenTok and saves it to a
     * database.
     * @param {string} patientEmail - A string representing the email address of the patient who is
     * participating in the session.
     * @param {string} doctorEmail - The email address of the doctor who will be participating in the
     * session.
     * @returns A Promise that resolves to a SessionDocument object.
     */
    async createSession(patientEmail: string, doctorEmail: string, appointment_id: string): Promise<SessionDocument> {
        const session = await this.sessionModel.findOne({patientEmail: patientEmail, doctorEmail: doctorEmail}).exec()
        if(session) {
            await this.sessionModel.deleteOne({patientEmail: patientEmail, doctorEmail: doctorEmail})
        }
        return new Promise<SessionDocument>((resolve, reject) => {
            opentok.createSession({ mediaMode: "routed" }, async (error, session) => {
                if (error) {
                console.log("Error creating session:", error);
                reject(error);
                } 
                else {
                    try {
                        const sessionRoom = await this.sessionModel.create({ sessionID: session.sessionId, patientEmail: patientEmail, doctorEmail: doctorEmail, appointment: appointment_id });
                        await sessionRoom.save();
                        console.log(sessionRoom);
                        resolve(sessionRoom);
                    } catch (error) {
                        console.log(error);
                        reject(error);
                    }
                }
            });
        });
    }


    // async getSessionDataAsPatient() {}


    async getSessionRoomAsPatient(user: User) {
        const sessionRoom = await this.sessionModel.findOne({'patientEmail': user.email})
        if(!sessionRoom) {
            throw new HttpException('Stream call session does not exist.', HttpStatus.NOT_FOUND)
        }
        return sessionRoom
    }



    /**
    * This function generates a token for a stream call session with a specified expiration time based
    * on the appointment's schedule date and duration.
    * @param {string} sessionID - A string representing the ID of a session in OpenTok.
    * @returns a token generated by the OpenTok API for a given session ID, with an expiration time
    * based on the appointment's schedule date and duration.
    */
    async generateToken(sessionID: string) {
        const session = await this.sessionModel.findOne({ sessionID: sessionID}).populate('appointment').exec()
        const appointment = session.appointment
        const streamCallTokenExpirationDate = new Date(appointment['date'])
        const appointmentDurationTime = appointment.duration

        const [hours, minutes] = appointmentDurationTime.split(":")
        streamCallTokenExpirationDate.setHours( streamCallTokenExpirationDate.getHours() + parseInt(hours, 10) )
        streamCallTokenExpirationDate.setMinutes( streamCallTokenExpirationDate.getMinutes() + parseInt(minutes, 10) )

        const tokenExpirationTime = Math.floor(streamCallTokenExpirationDate.getTime() / 1000)
        const options = {expireTime: tokenExpirationTime}
        const token = opentok.generateToken(sessionID, options);
        return token
    }


}