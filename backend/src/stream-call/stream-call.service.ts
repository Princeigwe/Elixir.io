import { HttpException, HttpStatus, Injectable } from '@nestjs/common';
import { Model } from 'mongoose';
import { InjectModel } from '@nestjs/mongoose';
import { Session, SessionDocument } from './session.schema';
import { User } from '../users/users.schema';


/* These lines of code are importing the `opentok` library and creating an instance of the `OpenTok`
class with the provided API key, secret, and options. The `opentok` instance is then used to create
sessions and generate tokens for stream calls. 

The timeout option is set to 60000 milliseconds, which is equivalent to 60 seconds. 
This means that if an API request takes longer than 60 seconds to receive a response from the OpenTok server, 
the request will be aborted and considered as timed out.
*/
// const OpenTok = require("opentok");
import * as OpenTok from 'opentok'
console.log(OpenTok)
// const opentok = new OpenTok(process.env.VONAGE_VIDEO_API_KEY || "12345", process.env.VONAGE_VIDEO_SECRET || "12345", { timeout: 60000});



@Injectable()
export class StreamCallService {
    constructor(
        @InjectModel(Session.name) private sessionModel: Model<SessionDocument>
    ) {}


    /**
     * This function creates a new session for a patient and a doctor using OpenTok and saves it to a
     * database.
     * @param {string} patientEmail - A string representing the email address of the patient who is
     * participating in the session.
     * @param {string} doctorEmail - The email address of the doctor who will be participating in the
     * session.
     * @returns A Promise that resolves to a SessionDocument object.
     */

    //todo: look at this later
    // async createSession(patientEmail: string, doctorEmail: string, appointment_id: string): Promise<SessionDocument> {
    //     const session = await this.sessionModel.findOne({patientEmail: patientEmail, doctorEmail: doctorEmail}).exec()
    //     if(session) {
    //         await this.sessionModel.deleteOne({patientEmail: patientEmail, doctorEmail: doctorEmail})
    //     }
    //     return new Promise<SessionDocument>((resolve, reject) => {
    //         opentok.createSession({ mediaMode: "routed" }, async (error, session) => {
    //             if (error) {
    //             console.log("Error creating session:", error);
    //             reject(error);
    //             } 
    //             else {
    //                 try {
    //                     const sessionRoom = await this.sessionModel.create({ sessionID: session.sessionId, patientEmail: patientEmail, doctorEmail: doctorEmail, appointment: appointment_id });
    //                     await sessionRoom.save();
    //                     console.log(sessionRoom);
    //                     resolve(sessionRoom);
    //                 } catch (error) {
    //                     console.log(error);
    //                     reject(error);
    //                 }
    //             }
    //         });
    //     });
    // }


    // async getSessionDataAsPatient() {}


    async getSessionRoomAsPatient(user: User) {
        const sessionRoom = await this.sessionModel.findOne({'patientEmail': user.email})
        if(!sessionRoom) {
            throw new HttpException('Stream call session does not exist.', HttpStatus.NOT_FOUND)
        }
        return sessionRoom
    }



    /**
    * This function generates a token for a stream call session with a specified expiration time based
    * on the appointment's schedule date and duration.
    * @param {string} sessionID - A string representing the ID of a session in OpenTok.
    * @returns a token generated by the OpenTok API for a given session ID, with an expiration time
    * based on the appointment's schedule date and duration.
    */

    //todo: look at this later
    // async generateToken(sessionID: string) {
    //     const session = await this.sessionModel.findOne({ sessionID: sessionID}).populate('appointment').exec()
    //     const appointment = session.appointment
    //     const streamCallTokenExpirationDate = new Date(appointment['date'])
    //     const appointmentDurationTime = appointment.duration

    //     const [hours, minutes] = appointmentDurationTime.split(":")
    //     streamCallTokenExpirationDate.setHours( streamCallTokenExpirationDate.getHours() + parseInt(hours, 10) )
    //     streamCallTokenExpirationDate.setMinutes( streamCallTokenExpirationDate.getMinutes() + parseInt(minutes, 10) )

    //     const tokenExpirationTime = Math.floor(streamCallTokenExpirationDate.getTime() / 1000)
    //     const options = {expireTime: tokenExpirationTime}
    //     const token = opentok.generateToken(sessionID, options);
    //     return token
    // }


}